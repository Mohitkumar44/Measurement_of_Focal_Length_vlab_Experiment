<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Convex / Concave Lens Optics Lab – VR</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  body{
    margin:0; overflow:hidden; background:#000;
    font-family:system-ui,sans-serif; color:#eee;
  }
  #info{
    position:absolute; top:16px; left:16px;
    background:rgba(0,0,0,.8); padding:10px 14px;
    border-radius:10px; font-size:14px; pointer-events:none;
    z-index:10; border:1px solid #444;
  }
  #controls{
    position:absolute; bottom:20px; left:50%; transform:translateX(-50%);
    background:rgba(0,0,0,.8); padding:15px 25px;
    border-radius:20px; display:flex; flex-direction:column; gap:10px;
    backdrop-filter:blur(5px); border:1px solid #444; min-width:300px;
    z-index:10;
  }
  .row{ display:flex; justify-content:space-between; align-items:center; font-size:13px; color:#ccc; }
  input[type=range] { width: 160px; accent-color: #4aa8ff; cursor: pointer; }
  .radio-group { display:flex; gap:15px; justify-content:center; margin-bottom:5px; }
  label { cursor:pointer; display:flex; align-items:center; gap:5px; font-weight:bold; }
  
  #readout{
    position:absolute; right:20px; bottom:100px;
    background:rgba(0,0,0,.8); padding:15px;
    border-radius:10px; font-family:monospace; font-size:13px;
    line-height:1.6; border:1px solid #444; pointer-events:none;
  }
  .val { color:#4aa8ff; font-weight:bold; }
  
  #VRButton { bottom: 20px !important; right: 20px !important; left: auto !important; }
</style>
</head>
<body>

<div id="info">
  <b>Physics Lab: Convex & Concave Lens</b><br>
  Object (Candle) → Lens → Image (Blue Arrow)<br>
  <span style="color:#aaa; font-size:12px;">Mouse: Rotate | Scroll: Zoom | Right Click: Pan</span>
</div>

<div id="readout">
  u: <span id="uVal" class="val">-28.0</span> cm<br>
  v: <span id="vVal" class="val">32.3</span> cm<br>
  f: <span id="fVal" class="val">15.0</span> cm<br>
  m: <span id="mVal" class="val">-1.15</span><br>
  Img Height: <span id="hiVal" class="val">-5.8</span> cm
</div>

<div id="controls">
  <div class="radio-group">
    <label><input type="radio" name="lensType" value="convex" checked> Convex Lens</label>
    <label><input type="radio" name="lensType" value="concave"> Concave Lens</label>
  </div>
  <div class="row">
    <span>Object Dist (u)</span>
    <input id="uSlider" type="range" min="15" max="50" value="28" step="0.5">
  </div>
  <div class="row">
    <span>Focal Length (f)</span>
    <input id="fSlider" type="range" min="10" max="25" value="15" step="1">
  </div>
  <div class="row">
    <span>Object Height</span>
    <input id="hSlider" type="range" min="2" max="10" value="5" step="0.5">
  </div>
</div>

<script type="importmap">
{ "imports":{ "three":"https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/":"https://unpkg.com/three@0.160.0/examples/jsm/" } }
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { VRButton } from 'three/addons/webxr/VRButton.js';

// --- 1. SCENE SETUP ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a1a1a);
scene.fog = new THREE.Fog(0x1a1a1a, 2, 8);

const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.01, 100);
camera.position.set(0.5, 1.6, 2.5);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);
document.body.appendChild(VRButton.createButton(renderer));

const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(0, 0.9, 0);
controls.enableDamping = true;
controls.maxDistance = 5;

// --- 2. LIGHTING & ENVIRONMENT ---
const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
scene.add(ambientLight);

const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
dirLight.position.set(2, 4, 3);
dirLight.castShadow = true;
dirLight.shadow.mapSize.set(2048, 2048);
scene.add(dirLight);

// Floor
const floorGeo = new THREE.PlaneGeometry(10, 10);
const floorMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 });
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI/2;
floor.receiveShadow = true;
scene.add(floor);

// Table
const tableY = 0.8;
const tableGeo = new THREE.BoxGeometry(3.5, 0.05, 1.0);
const tableMat = new THREE.MeshStandardMaterial({ color: 0x8B5A2B, roughness: 0.6 });
const table = new THREE.Mesh(tableGeo, tableMat);
table.position.y = tableY;
table.castShadow = true;
table.receiveShadow = true;
scene.add(table);

// Table Legs
const legGeo = new THREE.BoxGeometry(0.1, tableY, 0.1);
const legPos = [[-1.6, 0.4], [1.6, 0.4], [-1.6, -0.4], [1.6, -0.4]];
legPos.forEach(p => {
    const leg = new THREE.Mesh(legGeo, tableMat);
    leg.position.set(p[0], tableY/2, p[1]);
    leg.castShadow = true;
    scene.add(leg);
});

// Optical Rail
const railHeight = 0.02;
const railGeo = new THREE.BoxGeometry(3.2, railHeight, 0.15);
const railMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.4 });
const rail = new THREE.Mesh(railGeo, railMat);
rail.position.set(0, tableY + 0.035, 0);
rail.receiveShadow = true;
scene.add(rail);

// --- 3. OPTICS APPARATUS ---
const CM_TO_M = 0.02;
const OPTICAL_Y = tableY + 0.05 + 0.18;

// Materials
const metalMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.2 });
const blackMetalMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.6, roughness: 0.5 });
const glassMat = new THREE.MeshPhysicalMaterial({
    color: 0xffffff, metalness: 0.1, roughness: 0, 
    transmission: 0.99, thickness: 0.05, ior: 1.5, 
    transparent: true, side: THREE.DoubleSide
});

// -- OBJECT (Candle) --
const objGroup = new THREE.Group();
scene.add(objGroup);

const standBase = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.01, 0.12), blackMetalMat);
const standRod = new THREE.Mesh(new THREE.CylinderGeometry(0.008, 0.008, 0.15), metalMat);
standRod.position.y = 0.075;
objGroup.add(standBase, standRod);

const candleGeo = new THREE.CylinderGeometry(0.015, 0.015, 0.1);
const candleMat = new THREE.MeshStandardMaterial({ color: 0xFFF8DC });
const candle = new THREE.Mesh(candleGeo, candleMat);
objGroup.add(candle);

const flameGeo = new THREE.SphereGeometry(0.008);
const flameMat = new THREE.MeshBasicMaterial({ color: 0xFFaa00 });
const flame = new THREE.Mesh(flameGeo, flameMat);
objGroup.add(flame);

// -- LENS SETUP --
const lensGroup = new THREE.Group();
lensGroup.position.set(0, tableY + 0.05, 0);
scene.add(lensGroup);

const lensBase = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.01, 0.12), blackMetalMat);
const lensRod = new THREE.Mesh(new THREE.CylinderGeometry(0.008, 0.008, 0.18), metalMat);
lensRod.position.y = 0.09;
lensGroup.add(lensBase, lensRod);

// Ring Holder Parameters
const ringRadius = 0.16;
const tubeRadius = 0.008;

const lensRing = new THREE.Mesh(new THREE.TorusGeometry(ringRadius, tubeRadius, 16, 50), blackMetalMat);
lensRing.position.y = 0.18;
lensRing.rotation.y = Math.PI / 2;
lensGroup.add(lensRing);

let lensMesh = null;

function createLens(type) {
    if (lensMesh) {
        lensGroup.remove(lensMesh);
        lensMesh.geometry.dispose();
    }

    let points = [];
    const segments = 50;
    
    // Fit logic: Inner radius of ring = 0.16 - 0.008 = 0.152
    // We use exactly 0.152 so it sits inside the groove
    const radius = 0.152; 

    if (type === 'convex') {
        // Standard Convex Profile
        for(let i=0; i<=segments; i++) {
             const r = (i/segments) * radius;
             const halfThick = 0.025 * (1 - Math.pow(r/radius, 2)); // Parabolic
             points.push(new THREE.Vector2(r, halfThick));
        }
        points.push(new THREE.Vector2(radius, -0.001));
        for(let i=segments; i>=0; i--) {
             const r = (i/segments) * radius;
             const halfThick = 0.025 * (1 - Math.pow(r/radius, 2));
             points.push(new THREE.Vector2(r, -halfThick));
        }

    } else {
        // FIXED CONCAVE PROFILE
        // Thinner in center, Thicker at edge
        // Edge thickness should match ring roughly but stay contained
        const edgeHalfThick = 0.015; // 1.5cm edge thickness
        const centerHalfThick = 0.002; // Very thin center

        // Top Surface
        for(let i=0; i<=segments; i++) {
             const r = (i/segments) * radius;
             // Parabolic curve from center to edge
             const y = centerHalfThick + (edgeHalfThick - centerHalfThick) * Math.pow(r/radius, 2);
             points.push(new THREE.Vector2(r, y));
        }
        
        // Vertical Edge (Rim of the glass)
        points.push(new THREE.Vector2(radius, -edgeHalfThick));

        // Bottom Surface (Mirror of top)
        for(let i=segments; i>=0; i--) {
             const r = (i/segments) * radius;
             const y = centerHalfThick + (edgeHalfThick - centerHalfThick) * Math.pow(r/radius, 2);
             points.push(new THREE.Vector2(r, -y));
        }
    }

    const geometry = new THREE.LatheGeometry(points, 64);
    lensMesh = new THREE.Mesh(geometry, glassMat);
    
    // Rotate to face X-axis
    lensMesh.rotation.z = -Math.PI / 2; 
    
    // Align exactly with ring center
    lensMesh.position.y = 0.18;
    lensGroup.add(lensMesh);
}


// -- IMAGE ARROW (Virtual/Real) --
const arrowHelper = new THREE.ArrowHelper(
    new THREE.Vector3(0, 1, 0), 
    new THREE.Vector3(0, 0, 0), 
    1, 
    0x00aaff
);
scene.add(arrowHelper);


// -- RAYS --
const raysContainer = new THREE.Group();
scene.add(raysContainer);

function createRayLine(p1, p2, color, dashed=false) {
    const d = p1.distanceTo(p2);
    if(d < 0.001) return;
    const geo = new THREE.BufferGeometry().setFromPoints([p1, p2]);
    let mat;
    if(dashed) {
        mat = new THREE.LineDashedMaterial({ color: color, dashSize: 0.05, gapSize: 0.03 });
    } else {
        mat = new THREE.LineBasicMaterial({ color: color });
    }
    const line = new THREE.Line(geo, mat);
    if(dashed) line.computeLineDistances();
    raysContainer.add(line);
}


// --- 4. LOGIC UPDATE ---
const uSlider = document.getElementById('uSlider');
const fSlider = document.getElementById('fSlider');
const hSlider = document.getElementById('hSlider');
const radios = document.getElementsByName('lensType');

function updatePhysics() {
    const u_cm = parseFloat(uSlider.value);
    const f_cm = parseFloat(fSlider.value);
    const h_cm = parseFloat(hSlider.value);
    let type = 'convex';
    radios.forEach(r => { if(r.checked) type = r.value; });

    const u = -u_cm; 
    let f = f_cm;
    if(type === 'concave') f = -f_cm;

    let v_cm = 0;
    let isInfinity = false;

    const val = (1/f) + (1/u);
    if(Math.abs(val) < 0.001) {
        isInfinity = true;
        v_cm = 5000;
    } else {
        v_cm = 1 / val;
    }

    const m = v_cm / u;
    const h_img_cm = m * h_cm;

    // --- Update 3D Positions ---
    
    // 1. Object (Candle)
    const objX = u * CM_TO_M;
    objGroup.position.set(objX, tableY + 0.015, 0);
    
    const h_obj_m = h_cm * CM_TO_M;
    candle.scale.y = h_obj_m / 0.1;
    candle.position.y = 0.15 + (h_obj_m / 2);
    flame.position.y = 0.15 + h_obj_m + 0.01;

    // 2. Arrow (Image)
    const imgX = v_cm * CM_TO_M;
    if (!isInfinity) {
        arrowHelper.visible = true;
        arrowHelper.position.set(imgX, OPTICAL_Y, 0);
        const h_img_m = h_img_cm * CM_TO_M;
        if (h_img_m > 0) arrowHelper.setDirection(new THREE.Vector3(0, 1, 0));
        else arrowHelper.setDirection(new THREE.Vector3(0, -1, 0));
        
        arrowHelper.setLength(Math.abs(h_img_m), 0.05, 0.02);
    } else {
        arrowHelper.visible = false;
    }

    // --- Ray Tracing Visualization ---
    raysContainer.clear();
    const topObj = new THREE.Vector3(objX, OPTICAL_Y + h_obj_m, 0);
    const lensCenter = new THREE.Vector3(0, OPTICAL_Y, 0);
    const lensTop = new THREE.Vector3(0, OPTICAL_Y + h_obj_m, 0);
    
    const F_right = new THREE.Vector3(Math.abs(f)*CM_TO_M, OPTICAL_Y, 0);
    const F_left = new THREE.Vector3(-Math.abs(f)*CM_TO_M, OPTICAL_Y, 0);

    // Ray 1: Parallel -> Focus
    createRayLine(topObj, lensTop, 0xffff00);
    if(type === 'convex') {
        const dir = new THREE.Vector3().subVectors(F_right, lensTop).normalize();
        const end = lensTop.clone().add(dir.multiplyScalar(5));
        createRayLine(lensTop, end, 0xffff00);
    } else {
        const dir = new THREE.Vector3().subVectors(lensTop, F_left).normalize();
        const end = lensTop.clone().add(dir.multiplyScalar(5));
        createRayLine(lensTop, end, 0xffff00);
        createRayLine(F_left, lensTop, 0xffff00, true);
    }

    // Ray 2: Through Optical Center
    const dirCenter = new THREE.Vector3().subVectors(lensCenter, topObj).normalize();
    const endCenter = topObj.clone().add(dirCenter.multiplyScalar(6));
    createRayLine(topObj, endCenter, 0x00ff00);

    // Update HTML Labels
    document.getElementById('uVal').innerText = u_cm.toFixed(1);
    document.getElementById('vVal').innerText = isInfinity ? "Inf" : v_cm.toFixed(1);
    document.getElementById('fVal').innerText = f_cm.toFixed(1);
    document.getElementById('mVal').innerText = isInfinity ? "Inf" : m.toFixed(2);
    document.getElementById('hiVal').innerText = isInfinity ? "Inf" : h_img_cm.toFixed(1);
}

// Events
radios.forEach(r => r.addEventListener('change', () => {
    createLens(r.value);
    updatePhysics();
}));
uSlider.addEventListener('input', updatePhysics);
fSlider.addEventListener('input', updatePhysics);
hSlider.addEventListener('input', updatePhysics);

window.addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
});

renderer.setAnimationLoop(() => {
    controls.update();
    renderer.render(scene, camera);
});

// Init
createLens('convex');
updatePhysics();

</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic VR Optics Simulation (WebXR)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #info {
            position: absolute; top: 20px; left: 20px; color: #eee;
            background: rgba(20, 20, 20, 0.85); padding: 20px; border-radius: 12px;
            pointer-events: none; border: 1px solid #444; box-shadow: 0 0 20px rgba(0,0,0,0.5);
            max-width: 300px;
        }
        h2 { margin: 0 0 10px 0; font-size: 1.2rem; color: #fff; }
        .legend-item { display: flex; align-items: center; margin-bottom: 8px; font-size: 0.9rem; }
        .dot { width: 12px; height: 12px; border-radius: 50%; margin-right: 10px; display: inline-block; }
    </style>
</head>
<body>

<div id="info">
    <h2>VR Optics Simulation</h2>
    <div class="legend-item"><span class="dot" style="background:#ff3333; box-shadow: 0 0 8px #ff3333;"></span>Real OLED Panel</div>
    <div class="legend-item"><span class="dot" style="background:#aaddff; box-shadow: 0 0 8px #aaddff;"></span>Glass Lens (Refractive)</div>
    <div class="legend-item"><span class="dot" style="background:#00ff00; box-shadow: 0 0 8px #00ff00;"></span>Physical Light Rays</div>
    <div class="legend-item"><span class="dot" style="border: 2px dashed #ff00ff;"></span>Virtual Image (Hologram)</div>
    <p style="font-size: 0.8rem; color: #aaa; margin-top:10px;">
        Desktop: Mouse to rotate.<br>
        Mobile/Headset: Click 'ENTER VR'.
    </p>
</div>

<!-- Import Three.js and VRButton -->
<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { VRButton } from 'three/addons/webxr/VRButton.js';

    // --- Scene Setup ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050505);
    scene.fog = new THREE.FogExp2(0x050505, 0.3); // Adds depth

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 100);
    camera.position.set(0, 1.5, 2); // Position for Desktop view

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true; // Enable VR
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Add VR Button
    document.body.appendChild(VRButton.createButton(renderer));

    // Controls (Desktop)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1, 0);
    controls.update();

    // --- Lighting (Realistic Studio Setup) ---
    const ambientLight = new THREE.AmbientLight(0x404040, 2); 
    scene.add(ambientLight);

    const mainLight = new THREE.DirectionalLight(0xffffff, 2);
    mainLight.position.set(5, 10, 7);
    mainLight.castShadow = true;
    scene.add(mainLight);

    const blueRimLight = new THREE.PointLight(0x0088ff, 5, 20);
    blueRimLight.position.set(-2, 2, -2);
    scene.add(blueRimLight);

    // --- Container Group (To scale everything for VR) ---
    // VR works in meters. Our previous math was mm. We scale by 0.01
    const simGroup = new THREE.Group();
    simGroup.position.set(0, 1, -0.5); // Place it in front of user in VR
    simGroup.scale.set(0.01, 0.01, 0.01); 
    scene.add(simGroup);

    // --- Floor Grid (Reference) ---
    const gridHelper = new THREE.GridHelper(10, 20, 0x444444, 0x222222);
    scene.add(gridHelper);

    // --- MATERIALS (Realistic) ---
    
    // 1. Realistic Glass Material for Lens
    const glassMaterial = new THREE.MeshPhysicalMaterial({
        color: 0xffffff,
        metalness: 0,
        roughness: 0.05,
        transmission: 0.95, // Transparent like glass
        thickness: 2,
        ior: 1.5, // Index of Refraction for glass
        clearcoat: 1,
        clearcoatRoughness: 0.1,
    });

    // 2. Glowing Screen Material
    const screenMaterial = new THREE.MeshStandardMaterial({
        color: 0x000000,
        emissive: 0xff0000,
        emissiveIntensity: 2,
        roughness: 0.4
    });

    // 3. Holographic Virtual Image Material
    const holoMaterial = new THREE.MeshBasicMaterial({
        color: 0xff00ff,
        transparent: true,
        opacity: 0.15,
        side: THREE.DoubleSide,
        depthWrite: false,
        blending: THREE.AdditiveBlending
    });

    // --- GEOMETRY CONSTRUCTION ---

    // Constants
    const LENS_Z = 0;
    const SCREEN_Z = -30;
    const EYE_Z = 50;
    const FOCAL_LENGTH = 45;
    
    // Physics
    const u = Math.abs(SCREEN_Z - LENS_Z);
    const v = 1 / ( (1/u) - (1/FOCAL_LENGTH) ); // Virtual distance
    const mag = v / u;
    const virtZ = LENS_Z - v;

    // A. The Lens
    const lensGeo = new THREE.SphereGeometry(25, 64, 64);
    lensGeo.scale(1, 1, 0.15);
    const lens = new THREE.Mesh(lensGeo, glassMaterial);
    lens.position.z = LENS_Z;
    simGroup.add(lens);

    // B. The Physical Screen
    const screenGeo = new THREE.BoxGeometry(15, 15, 1);
    const screen = new THREE.Mesh(screenGeo, screenMaterial);
    screen.position.z = SCREEN_Z;
    simGroup.add(screen);

    // C. The Eye (Simplified)
    const eyeGroup = new THREE.Group();
    const eyeBall = new THREE.Mesh(
        new THREE.SphereGeometry(10, 32, 32),
        new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 })
    );
    const iris = new THREE.Mesh(
        new THREE.SphereGeometry(5, 32, 16),
        new THREE.MeshStandardMaterial({ color: 0x222222 })
    );
    iris.position.z = 8;
    iris.scale.z = 0.2;
    eyeGroup.add(eyeBall);
    eyeGroup.add(iris);
    eyeGroup.position.z = EYE_Z;
    eyeGroup.rotation.y = Math.PI; // Look at lens
    simGroup.add(eyeGroup);

    // D. Virtual Image (The Hologram)
    const virtSize = 15 * mag;
    const virtGeo = new THREE.PlaneGeometry(virtSize, virtSize);
    const virtImage = new THREE.Mesh(virtGeo, holoMaterial);
    virtImage.position.z = virtZ;
    
    // Add a border to virtual image
    const edges = new THREE.EdgesGeometry(virtGeo);
    const lineMat = new THREE.LineBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.5 });
    const wireframe = new THREE.LineSegments(edges, lineMat);
    virtImage.add(wireframe);
    
    simGroup.add(virtImage);

    // E. Light Rays (Glowing Beams)
    const corners = [ [7, 7], [-7, 7], [7, -7], [-7, -7] ]; // Half size of screen
    
    corners.forEach(c => {
        const lx = c[0] * 1.5;
        const ly = c[1] * 1.5;

        // 1. Real Ray (Screen -> Eye)
        const curve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(c[0], c[1], SCREEN_Z),
            new THREE.Vector3(lx, ly, LENS_Z),
            new THREE.Vector3(0, 0, EYE_Z)
        ]);
        const tubeGeo = new THREE.TubeGeometry(curve, 20, 0.2, 8, false);
        const tubeMat = new THREE.MeshBasicMaterial({ 
            color: 0x00ff00, 
            transparent: true, 
            opacity: 0.6,
            blending: THREE.AdditiveBlending 
        });
        const ray = new THREE.Mesh(tubeGeo, tubeMat);
        simGroup.add(ray);

        // 2. Virtual Projection (Dashed Line)
        const vPoints = [
            new THREE.Vector3(lx, ly, LENS_Z),
            new THREE.Vector3(c[0]*mag, c[1]*mag, virtZ)
        ];
        const vGeo = new THREE.BufferGeometry().setFromPoints(vPoints);
        const vMat = new THREE.LineDashedMaterial({ 
            color: 0xff00ff, 
            dashSize: 2, 
            gapSize: 2, 
            opacity: 0.4, 
            transparent: true 
        });
        const vLine = new THREE.Line(vGeo, vMat);
        vLine.computeLineDistances();
        simGroup.add(vLine);
    });

    // --- Animation Loop ---
    renderer.setAnimationLoop(function () {
        // Rotate the simulation slowly for better 3D effect in desktop
        if(!renderer.xr.isPresenting) {
            // simGroup.rotation.y += 0.005;
        }
        
        // Gentle pulse effect on rays
        const time = performance.now() / 1000;
        const pulse = (Math.sin(time * 2) + 1) * 0.5; // 0 to 1
        
        simGroup.children.forEach(child => {
            if(child.geometry && child.geometry.type === 'TubeGeometry') {
                child.material.opacity = 0.3 + (pulse * 0.3);
            }
        });

        controls.update();
        renderer.render(scene, camera);
    });

    // Resize Handler
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
